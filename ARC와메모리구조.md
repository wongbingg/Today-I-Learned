
# ARC 와 메모리구조

## ARC

스위프트는 앱의 메모리 사용을 추적하고 관리하기 위해 ARC를 사용한다. 하여, 스스로 메모리 관리에 대한 생각을 할 필요가 없다. 자동으로 해주기 때문에 !! 
Auto Reference Count, 클래스와 클로저 같은 참조 타입을 다룰 때, 참조 카운트를 통해 해당 인스턴스를 참조하고 있는 변수,상수,파라미터 등의 수를 헤아려서 카운트 값이 하나라도 남아있다면, Heap 에서 해제되지 않도록 하는 것이다. 

그러나, 몇몇의 경우 메모리 관리를 위해 ARC 는 코드 사이 관계에 대한 더 많은 정보를 요구한다 
### Strong Reference Cycles
**1. Between Class Instance**
두 클래스 인스턴스가 서로를 참조하는 경우 강한 순환참조가 발생한다. 
```swift=
class A { 
}

class B {
}
```

두 클래스 인스턴스를 받는 변수나 상수에 nil을 할당해도, Heap 영역에서 서로를 참조하고 있기 때문에 , 이를 해결하기 위한 방법이 제시된다.
**경우1 해결방법** : 서로를 참조하는 두 `클래스A`, `클래스B` 를 각각 변수 a,b 에 할당했다고 가정해보면, 인스턴스 중 먼저 nil이 되는 것 즉, 수명이 짧은 `클래스A` 를 참조할 때는 ==weak== 키워드를 이용한다. ==weak== 키워드를 이용하면 강한 참조가 아닌 약한참조를 하게되어 참조 카운트를 증가시키지 않는다. 그렇게 되면 약한 참조를 당하는 `클래스A` 입장에서는 해당 인스턴스를 할당한 `변수a`가 nil 값이 될 때, 그 클래스를 참조하는 카운트는 0이 되어 먼저 Heap영역에서 사라지고, 이 클래스를 참조하던 다른 `클래스B`의 weak 참조는 자동으로 nil이 된다. 또한 기존에 `클래스B` 를 강한참조 하던 `클래스A` 가 할당 해제 되었으므로 이 강한참조도 사라지게 되어 `클래스B`를 가리키는 참조는 `변수a` 만 남는다. 즉 , 참조카운트가 1이 된다. 이젠 `변수b` 에 nil을 할당하게 되면 정상적으로 `클래스B` 가 Heap 영역에서 할당해제 된다. 
![](https://i.imgur.com/LYSzG3L.png)
![](https://i.imgur.com/d1Yb4T8.png)
</br>
**경우2 해결방법** : 위 경우와 다르게, 다른 인스턴스가 같은 수명 또는 더 긴 수명을 가질 때 ==unowned== 키워드를 사용한다. 위와 같은 예시에서 `클래스B` 에서는 `클래스A`를 확실하게 가지고있고, 그 반대는 옵셔널인 경우로 바뀌었다. 이 경우도 마찬가지로 강한 순환참조가 일어나 메모리 누수현상이 발생한다. ==unowned== 참조는 참조가 항상 할당해제 되지 않은 인스턴스를 참조한다고 확신할 때 사용한다. 즉, 이 경우 `클래스B` 의 friend 프로퍼티 앞에 키워드를 붙여주게 되면 강한 순환참조가 해결된다. 
![](https://i.imgur.com/e2pF3NV.png)
![](https://i.imgur.com/8fVsUfn.png)
![](https://i.imgur.com/rshk1P5.png)
