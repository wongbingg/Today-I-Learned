###### tags: `디자인패턴`

# 데코레이터 패턴

## 🔘 의도

**데코레이터**는 객체들을 새로운 행동들을 포함한 특수 래퍼 객체들 내에 넣어서 위 행동들을 해당 객체들에 연결시키는 구조적 디자인 패턴.

> 객체의 결합을 통해 기능을 동적으로 유연하게 확장 할 수 있게 해주는 패턴


![](https://i.imgur.com/ajaORU5.png)

## 🔘 문제

당신이 알림 라이브러리를 만들고 있다고 상상해보세요. 이 알림 라이브러리의 목적은 다른 프로그램들이 사용자들에게 중요한 이벤트들에 대해 알릴 수 있도록 하는 것입니다. 

라이브러리의 초기 버전은 Notifier(알림자) 클래스를 기반했다. 이 클래스에는 몇 개의 필드들, 하나의 생성자 그리고 단일 `send()` 메서드만 있다. 이 메서드는 클라이언트로부터 메세지 인수를 받은 후 그 메세지를 알림자의 생성자를 통해 알림자에게 전달된 이메일 목록으로 보낼 수 있다. 또 클라이언트 역할을 한 타사 앱은 알림자 객체를 한번 생성하고 설정한 후 중요한 일이 발생할 때마다 사용하게 되어 있었다. 

![](https://i.imgur.com/ZGwMelz.png)


그런데, 어느 시점에서 이메일 알림 이상 (SMS문자 메세지, 페이스북알림, 슬랙 알림 등) 을 받고 싶어졌다.
![](https://i.imgur.com/7HwEzqS.png)

Notifier 클래스를 확장하고, 추가 알림 메서드들을 새 작식 클래스에 넣어 이제 클라이언트가 사용자가 원하는 알림 클래스를 인스턴스화하고 모든 추가 알림에 사용하도록 앱을 설계했다.

`여러 유형의 알림을 한 번에 사용할 수 는 없나? `

이 문제 해결을 위해 당신은 하나의 클래스 내에서 여러 알림 메서드를 합성한 특수 자식 클래스들을 만들었으나, 이 접근 방식은 라이브러리 코드뿐 아니라 클라이언트 코드도 엄청나게 부풀릴 것이다.

![](https://i.imgur.com/4nwtchd.png)

## 해결책

객체의 동작을 변경해야 할 때 가장 먼저 고려되는 방법은 클래스 확장이다. 그러나 상속에는 주의해야 할 몇가지 사항들이 있다. 
- 상속은 정적이다 : 당신은 런타임때 기존 객체의 행동을 변경할 수 없다. 당신은 전체 객체를 다른 자식클래스에서 생성된 다른 객체로만 바꿀 수 있다.
- 자식 클래스는 하나의 부모 클래스만 가질 수 있다. 대부분 언어에서의 상속은 클래스가 동시에 여러 클래스의 행동을 상속하도록 허용하지 않는다.

이런 주의 사항을 극복하는 방법중 하나는 상속 대신 **집합관계 또는 합성**을 사용하는 것이다. 두 대안 모두 거의 같은 방식으로 작동한다. 집합 관계에서는 한 객체가 다른 객체에 대한 참조를 갖고 일부 작업을 위임하는 반면, 상속을 사용하면 객체 자체가 부모 클래스에서 행동을 상속한 후 해당 작업을 수행할 수 있다. 

이 새로운 접근 방식을 사용하면 연결된 '도우미' 객체를 다른 객체로 쉽게 대체하여 런타임 때 컨테이너의 행동을 변경할 수 있다. 객체는 여러 클래스의 행동들을 사용할 수 있고, 여러 객체에 대한 참조들이 있으며 이 객체들에 모든 종류의 작업을 위임한다. 집합 관계/합성은 데코레이터를 포함한 많은 디자인 패턴의 핵심 원칙이다. 그러면 이제 다시 이 패턴을 살펴보자

![](https://i.imgur.com/hc39bPY.png)

'래퍼' 는 패턴의 주요 아이디어를 명확하게 표현하는 데코레이터 패턴의 별명이다. 래퍼는 일부 대상 객체와 연결할 수 있는 객체이다. 래퍼에는 대상 객체와 같은 메서드들의 집합이 포함되어 있으며, 래퍼는 자신이 받는 모든 요청을 대상 객체에 위임한다. 그러나 래퍼는 이 요청을 대상에 전달하기 전이나 후에 무언가 를 수행하여 결과를 변경할 수 있다. 

그러면 간단한 래퍼는 언제 진정한 데코레이터가 될 수 있을까? 앞서 언급했듯이 래퍼는 래핑된 객체와 같은 인터페이스를 구현한다. 그러므로 클라이언트 관점에서 이러한 객체들은 같다. 이제 래퍼의 참조 필드가 해당 인터페이스를 다르는 모든 객체를 받도록 하자. 이렇게 하면 여러 래퍼로 객체를 포장해서 모든 래퍼들의 합성된 행동들을 객체에 추가할 수 있다. 

이제 당신의 알림 라이브러리에서 기초 Notifier 클래스 내에 있는 간단한 이메일 알림 행동은 그대로 두고 다른 모든 알림 메서드들을 데코레이터로 바꿔본다. 

![](https://i.imgur.com/hgafznK.png)

클라이언트 코드는 기초 알림자 객체를 클라이언트의 요구사항들과 일치하는 데코레이터들의 집합으로 래핑해야 한다. 위 결과 객체들을 스택으로 구성된다.
![](https://i.imgur.com/brrGUEt.png)

스택의 마지막 데코레이터는 실제로 클라이언트와 작업하는 객체이다. 모든 데코레이터들은 기초 알림자와 같은 인터페이스를 구현하므로 나머지 클라이언트 코드는 자신이 순수한 알림자 객체와 작동하든 데코레이터로 장식된 알림자 객체와 함께 작동하든 상관하지 않는다.

메세지 형식 지정 또는 수신자 리스트 작성과 같은 다른 행동들에도 같은 접근 방식을 적용할 수 있다. 클라이언트 객체가 다른 객체들과 같은 인터페이스를 따르는 한 객체를 모든 사용자 지정 데코레이터로 장식할 수 있다.


## 구조
![](https://i.imgur.com/Wzy56Ms.png)

1. `컴포넌트` 는 래퍼들과 래핑된 객체들 모두에 대한 공통 인터페이스를 선언한다.
2. `구상 컴포넌트`는 래핑되는 객체들의 클래스이며, 그는 기본 행동들을 정의하고 해당 기본 행동들은 데코레이터들이 변경할 수 있다.
3. 기초 데코레이터 클래스에는 래핑된 객체를 참조하기 위한 필드가 있다. 필드의 유형은 구상 컴포넌트들과 구상 데코레이터들을 모두 포함할 수 있도록 컴포넌트 인터페이스로 선언되어야 한다. 그 후 기초 데코레이터는 모든 작업들을 래핑된 객체에 위임한다. 
4. 구상 데코레이터들은 컴포넌트들에 동적으로 추가될 수 있는 추가 행동들을 정의한다. 그들은 기초 데코레이터의 메서드를 오버라이드 하고 해당 행동을 부모 메서드를 호출하기 전이나 후에 실행한다. 
5. 클라이언트는 아래에 언금한 데코레이터들이 컴포넌트 인터페이스를 통해 모든 객체와 작동하는 한 컴포넌트들을 여러 계층의 데코레이터들로 래핑할 수 있다.

## 적용

> 데코레이터 패턴은 이 객체들을 사용하는 코드를 훼손하지 않으면서 런타임에 추가 행동들을 객체들에 할당할 수 있어야 할 때 사용해라.

- 데코레이터는 비즈니스 로직을 계층으로 구성하고, 각 계층에 데코레이터를 생성하고 런타임에 이 로직의 다양한 조합들로 객체들을 구성할 수 있도록 한다. 이러한 모든 객체가 공통 인터페이스를 따르기 때문에 클라이언트 코드는 해당 모든 객체를 같은 방식으로 다룰 수 있다.

> 이 패턴을 상속을 사용하여 객체의 행동을 확장하는 것이 어색하거나 불가능하 때 사용해라.

- 많은 프로그래밍 언어에는 클래스의 추가 확장을 방지하는 데 사용할 수 있는 final 키워드가 있다. Final 클래스의 경우 기존 행동들을 재사용할 수 있는 유일한 방법은 데코레이터 패턴을 사용하여 클래스를 자체 래퍼로 래핑하는 것이다. 

## 구현 방법
1. 당신의 비즈니스 도메인이 여러 선택적 계층으로 감싸진 기본 컴포넌트로 표시될 수 있는지 확인해라.
2. 기본 컴포넌트와 선택적 계층들 양쪽에 공통적인 메서드들이 무엇이지 파악해라. 그곳에 컴포넌트 인터페이스를 만들고 해당 메서드들을 선언해라.
3. 구상 컴포넌트 클래스를 만든 후 그 안에 기초 행동들을 정의해라.
4. 기초 데코레이터 클래스를 만들어라. 이 클래스에는 래핑된 객체에 대한 참조를 저장하기 위한 필드가 있어야 한다. 이 필드는 데코레이터들 및 구상 컴포넌트들과의 연결을 허용하기 위하여 컴포넌트 인터페이스 유형으로 선언해야 한다. 기초 데코레이터는 모든 작업을 래핑된 객체에 위임해야 한다.
5. 모든 클래스들이 컴포넌트 인터페이스를 구현하도록 해라.
6. 기초 데코레이터를 확장하여 구상 데코레이터를 생성하라. 구상 데코레이터는 항상 부모 메서드 호출 전 또는 후에 행동들을 실행해야 한다.(부모 메서드는 항상 래핑된 객체에 작업을 위임한다.)
7. 데코레이터들을 만들고 이러한 데코레이터들을 클라이언트가 필요로 하는 방식으로 구성하는 일은 반드시 클라이언트 코드가 맡아야 한다.

## 장단점 

| 🟢 장점 | 🔴 단점 |
| :------: | :------: |
| 새 자식 클래스를 만들지 않고도 객체의 행동을 <br>확장할 수 있다.     | 래퍼들의 스택에서 특정 래퍼를 제거하기가 어렵다. |
|런타임에 객체들에서부터 책임들을 추가하거나 제거할 수 있다.|데코레이터의 행동이 데코레이터 스택 내의 순서에 의존하지 않는 방식으로 데코레이터를 구현하기가 어렵다|
|객체를 여러 데코레이터로 래핑하여 여러 행동들을 합성할 수 있다.|계층들의 초기 설정 코드가 보기 흉할 수 있다.|
|SRP. 다양한 행동들의 여러 변형들을 구현하는 모놀리식 클래스를 여러 개의 작은 클래스들로 나눌 수 있다.||


## 🔗 Reference

- [Refactoring Guru - Decorator Pattern](https://refactoring.guru/ko/design-patterns/decorator)
- [참조 블로그](https://coding-factory.tistory.com/713)
- [참조 블로그](http://throughkim.kr/2019/09/09/swift-decorator/)
